import user_global_share

class user_signature_generation_share:
    def __init__(self, generating_user_id : str, target_user_index : int, target_user_evaluation : int, v_is, v0):
        """
        v_i = g^ai - where ai is the coefficient of the shamir polynomial generated by generating user
        v_0 - g^secret
        """
        self.generating_user_id = generating_user_id
        self.target_user_index = target_user_index
        self.target_user_evaluation = target_user_evaluation
        self.g_pow_coeffcients_list = v_is
        self.v0 = v0
        pass

    def generate_global_share_from_users_share(self, index : int, all_users_shares : list) -> user_global_share:
        """
        The final signature of the transaction would be the sum of u_i
        where u_i is the (secret) share of every user.
        Denoting by p_i(x) the polynomial of user i [e.g u_i = p_i(0)]
        If we denote P(x): = sum_i pi(x), then P(0) = x - the secret key for generation.
        Moreover, player j need P(j) as his share, but it's given by summing over p_i(j) 
        Player j evaluation of  
        """
        evaluation = sum(user_share.target_user_evaluation for user_share in all_users_shares )
        return user_global_share(index, evaluation)

