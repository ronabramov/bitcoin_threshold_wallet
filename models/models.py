from pydantic import BaseModel
from typing import List, Optional
from ecdsa.ellipticcurve import PointJacobi
from ecdsa import curves
from phe import paillier


class TransactionInfo(BaseModel):
    wallet_id: str
    transaction_details: dict

class Message(BaseModel):
    recipient_id: str
    content: str

class user_key_generation_share(BaseModel):
    """
    Consider p as the polynomial generated by the user produced this share.
    target_user_evaluation : evaulated polynomial at target user index
    v_i = g^ai - where ai is the coefficient of the shamir polynomial generated by generating user
    v_0 - g^secret
    This share can be tested for validness through Feldaman_VSS_Protocl.Verify_Share method.
    curve : The curved used for the generation.
    """
    transaction_id : str
    generating_user_id : str
    target_user_matrix_id : str
    target_user_index : int
    target_user_evaluation : int
    v_i = List[PointJacobi]
    v_0 : PointJacobi
    curve : str

    def get_type():
        return f"user_key_share"
    
class user_signature_share(BaseModel):
    """
    Includes user secrets - MUSTN'T BE BROADCASTED OR SHARED
    Denote by P = sum_j p_j , where p_j are the generated polynomial by the jth player.
    The Shamir share of the secret key of the Signature x = sum_j u_j is given by
    P(user_index) =  sum_j p_j(user_index)       --- x = P(0)
    The share a user should posses along the signature algorithm
    Composed from shares of all other users participated in the transaction
    user_evaluation - the user secret key. 
    """
    user_index : int
    user_id : str
    user_evaluation : int
    group : curves.Curve
    paillier_secret_key, paillier_public_key = paillier.generate_paillier_keypair()
    modulus_N : int

class public_user_data(BaseModel):
    user_index : int
    user_id : int
    paillier_public_key : paillier.PaillierPublicKey
    modulus_N : int 

    

